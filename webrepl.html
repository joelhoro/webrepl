<!doctype html>
<html>
<head>
<title>MicroPython WebREPL</title>
<!--
  term.js
  Copyright (c) 2012-2013, Christopher Jeffrey (MIT License)
  Copyright (c) 2016, Paul Sokolovsky
-->
<!-- <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"> -->

<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.5.6/angular.min.js"></script>
<script src="term.js"></script>
<script src="FileSaver.js"></script>
</head>
<body>

<div ng-app='webrepl' ng-controller='main'>


<table>
    <col width='60%'>
    <col width='40%'>
    <tr>
        <td>
    <!-- <div style="display:inline-block; vertical-align:top;"> -->
            
            <div id="file-boxes">
                <input type='button' id='connect_button' value='Connect' onclick="button_click(); return false;" />
                <button onclick="reset(); button_click();">Soft reset</button>
                    <input type="text" name="webrepl_url" id="url" value="ws://ESP2:8266/" />
                    <br>
                    <h1>
            
                        Scratchpad
                    </h1>
                            <textarea class='scratchpad' id="scratchpad0" onkeypress='scratchpadKeypress(0,event)' rows="10" cols="80">
print("Hello")
for i in range(10):
    print("Line ", i)

def test():
    print("Hello")

                                        </textarea>
                            <i>Ctrl-Enter to send entire scratchpad to REPL<br>
                            <i>Shift-Enter to send current selection to REPL<br><br>
                    <div class="file-box">
                                        <button class='btn' onclick='save_buffer()'>Save file</button>
                                            <input  id='put_filename' ng-model='fileName' /> 
                        <!-- <strong>Send a file</strong>
                        <!-- <input type="file" id="put-file-select" /> -->
                        <!-- <div id="put-file-list"></div>
                        <input type="button" value="Send to device" id="put-file-button" onclick="put_file(); return false;" /> --> 
                    </div>
                    
                    <div class="file-box">
                        <button ng-click='refreshDirectories()'>Refresh directory</button> 
                        <button class='btn'  ng-click="getfile()" >Get from device</button>
                        <select id='fileSelector' ng-model='activeFileIdx' ng-change="changeFolder()">
                            <option ng-repeat='file in files track by $index' value='{{$index}}'>
                                {{file.displayName}} ({{file.size}} bytes)
                            </option>
                        </select>
                        <button ng-click='runFile()'>Run</button>
                        <button ng-click='importFile()'>Import</button>
                    </div>
                    
                    <div class="file-box" id="file-status">...</span></div>                    
                
                    </div>
                    <!-- <br clear="both" /> -->
                    <br>
                    <i>Terminal widget should be focused (text cursor visible) to accept input. Click on it if not.</i><br/>
                    <i>To paste, press Ctrl+A, then Ctrl+V</i>

                </div>     
        
        </td>
        <td>
            <div class='terminal' id="term">
                    <h1>REPL</h1>
            </div>
        </td>
    </tr>
</table>
    
</div>


</body>

<link rel="stylesheet" href="style.css">
<link rel="stylesheet" href="lib/codemirror.css">
<script src="https://cdn.jsdelivr.net/npm/codemirror@5.44.0/lib/codemirror.min.js"></script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.44.0/mode/python/python.min.js'></script>

<script>
"use strict"

  var editor = CodeMirror.fromTextArea(document.getElementById("scratchpad0"), {
    lineNumbers: true,
    mode: 'python',
    extraKeys: {
        "Ctrl-Enter" : function(cm) {
            sendText(cm.getValue());
        },
        "Ctrl-S" : function(cm) {
            save_buffer();
        },
        "Shift-Enter" : function(cm) {
            var selection = cm.getSelection()
            if(selection == "") {
                var currentLine = cm.getCursor().line;
                selection = cm.getLine(currentLine);
                cm.setCursor(currentLine+1);
            }
            // if by now the selection is not empty...
            if(selection != "")
                sendText(selection);

        }

    }
  });


var SERVICE_MESSAGE_EVENT = 'SERVICE_MESSAGE_EVENT';
var FILE_PUT_EVENT = 'FILE_PUT_EVENT';

var FILETYPE_FOLDER = 0x4000;
var FILETYPE_FILE = 0x8000;

var PYTHON_RESETMACHINE = 'import time, machine; print("Resetting..."); time.sleep(1); machine.reset()'
var PYTHON_STARTUPDEFINITIONS = `
import os, time
def execute_file(file_name, tmp_file = False):
    text = open(file_name).read()
    # removing the file before anything bad can happen
    if tmp_file:
        os.remove(file_name)

    banner = "========================    %s    ========================"
    print(banner % file_name)
    print(text)
    print("=" * ( len(banner) - 2 + len(file_name) ) )
    try:
        start_time = time.ticks_us()
        ### really not clear if we should pass globals or not...
        #exec(text,globals())
        exec(text)
        end_time = time.ticks_us()
        print("=== %.3fms elapsed" % ((end_time-start_time)/1000.0))
    except Exception as e:
        print("Could not run %s: %s" % (file_name,e))

print("Initialization completed")
`


var listeners = {}
function addListener(eventType, name, cb) {
    document.addEventListener(eventType, cb);
    listeners[name] = cb;
}

function removeListener(eventType, name) {
    document.removeEventListener(eventType, listeners[name]);
    delete(listeners[name]);
}



var term;
var ws;
var connected = false;
var replReady = false;
var binary_state = 0;
var put_file_name = null;
var put_file_data = null;
var get_file_name = null;
var get_file_data = null;

function calculate_size(win) {
    var cols = Math.max(80, Math.min(120, (win.innerWidth - 500) / 12)) | 0;
    var rows = Math.max(24, Math.min(40, (win.innerHeight - 220) / 18)) | 0;
    return [cols, rows];
}

(function() {
    window.onload = function() {
      var size = calculate_size(self);
      term = new Terminal({
        cols: size[0],
        rows: size[1],
        //useStyle: true,
        screenKeys: true,
        cursorBlink: false,

      });
      term.open(document.getElementById("term"));
      show_https_warning();
      button_click();
    };
    window.addEventListener('resize', function() {
        var size = calculate_size(self);
        term.resize(size[0], size[1]);
    });
}).call(this);

function show_https_warning() {
    if (window.location.protocol == 'https:') {
        var warningDiv = document.createElement('div');
        warningDiv.style.cssText = 'background:#f99;padding:5px;margin-bottom:10px;line-height:1.5em;text-align:center';
        warningDiv.innerHTML = [
            'At this time, the WebREPL client cannot be accessed over HTTPS connections.',
            'Use a HTTP connection, eg. <a href="http://micropython.org/webrepl/">http://micropython.org/webrepl/</a>.',
            'Alternatively, download the files from <a href="https://github.com/micropython/webrepl">GitHub</a> and run them locally.'
        ].join('<br>');
        document.body.insertBefore(warningDiv, document.body.childNodes[0]);
        term.resize(term.cols, term.rows - 7);
    }
}

function reset() {
    sendServiceMessage(PYTHON_RESETMACHINE)
}

function button_click() {
    if (connected) {
        ws.close();
    } else {
        document.getElementById('url').disabled = true;
        document.getElementById('connect_button').value = "Disconnect";
        connected = true;
        connect(document.getElementById('url').value);
    }
}

function prepare_for_connect() {
    document.getElementById('url').disabled = false;
    document.getElementById('connect_button').value = "Connect";
}

function update_file_status(s) {
    document.getElementById('file-status').innerHTML = s;
}

function sendBuffer(buffer) {
    console.log("Sending buffer: ", buffer);
    for (var offset = 0; offset < buffer.length; offset += 1024) {
        console.log(offset, " --> ", offset + 1024);
        ws.send(buffer.slice(offset, offset + 1024));
    }
}

function getPrompt(data) {
    var promptSymbol = />>> $/;
    var prompt = ">>> ";
    if (data.match(promptSymbol))
        data = data.replace(promptSymbol, new Date().toLocaleTimeString() + " " + prompt);
    term.write(data);
}

function connect(url) {
    ws = new WebSocket(url);
    ws.binaryType = 'arraybuffer';
    ws.onopen = function() {
        ws.send("\n");
        term.removeAllListeners('data');
        term.on('data', function(data) {
            // Pasted data from clipboard will likely contain
            // LF as EOL chars.
            data = data.replace(/\n/g, "\r");
            ws.send(data);
        });

        term.on('title', function(title) {
            document.title = title;
        });

        term.focus();
        term.element.focus();
        term.write('\x1b[32mWelcome to MicroPython!\x1b[m\r\n');
        //refreshDirectories();

        ws.onmessage = function(event) {
            if (event.data instanceof ArrayBuffer) {
                var data = new Uint8Array(event.data);
                switch (binary_state) {
                    case 11:
                        // first response for put
                        if (decode_resp(data) == 0) {
                            // send file data in chunks
                            for (var offset = 0; offset < put_file_data.length; offset += 1024) {
                                ws.send(put_file_data.slice(offset, offset + 1024));
                            }
                            binary_state = 12;
                        }
                        break;
                    case 12:
                        // final response for put
                        var success = decode_resp(data) == 0;
                        if (success) {
                            update_file_status('Sent ' + put_file_name + ', ' + put_file_data.length + ' bytes');
                        } else {
                            update_file_status('Failed sending ' + put_file_name);
                        }
                        var fileSaveEvent = new CustomEvent(FILE_PUT_EVENT, { 
                            detail: { success, name: put_file_name }
                        });
                        binary_state = 0;
                        document.dispatchEvent(fileSaveEvent);
                        break;

                    case 21:
                        // first response for get
                        if (decode_resp(data) == 0) {
                            binary_state = 22;
                            var rec = new Uint8Array(1);
                            rec[0] = 0;
                            ws.send(rec);
                        }
                        break;
                    case 22: {
                        // file data
                        var sz = data[0] | (data[1] << 8);
                        if (data.length == 2 + sz) {
                            // we assume that the data comes in single chunks
                            if (sz == 0) {
                                // end of file
                                binary_state = 23;
                            } else {
                                // accumulate incoming data to get_file_data
                                var new_buf = new Uint8Array(get_file_data.length + sz);
                                new_buf.set(get_file_data);
                                new_buf.set(data.slice(2), get_file_data.length);
                                get_file_data = new_buf;
                                update_file_status('Getting ' + get_file_name + ', ' + get_file_data.length + ' bytes');

                                var rec = new Uint8Array(1);
                                rec[0] = 0;
                                ws.send(rec);
                            }
                        } else {
                            binary_state = 0;
                        }
                        break;
                    }
                    case 23:
                        // final response
                        if (decode_resp(data) == 0) {
                            update_file_status('Got ' + get_file_name + ', ' + get_file_data.length + ' bytes');
                            //saveAs(new Blob([get_file_data], {type: "application/octet-stream"}), get_file_name);
                            editor.setValue(Array.from(get_file_data).map(x => String.fromCharCode(x)).join(''))
                        } else {
                            update_file_status('Failed getting ' + get_file_name);
                        }
                        binary_state = 0;
                        break;
                    case 31:
                        // first (and last) response for GET_VER
                        console.log('GET_VER', data);
                        binary_state = 0;
                        break;
                }
            }
            else if(serviceMessageInProcess) {
                if(event.data == '>>> ') {
                    console.log("Complete message: ", serviceMessageResponse);
                    var serviceMessageEventCompleted = new CustomEvent(SERVICE_MESSAGE_EVENT, {
                        detail: {
                            message: serviceMessageResponse
                        }
                    });

                    document.dispatchEvent(serviceMessageEventCompleted)
                    term.write(serviceMessageResponse);
                    term.write(getPrompt(event.data));
                }
                else {
                    serviceMessageResponse += event.data;
                }
            }
            else {
                // if(event.data.indexOf("WebREPL connected")>=0)
                //     refreshDirectories();
                replReady = true;
                term.write(getPrompt(event.data));
            }
        };
    };

    ws.onclose = function() {
        connected = false;
        startUpReady = false;
        replReady = false;
        if (term) {
            term.write('\x1b[31mDisconnected\x1b[m\r\n');
        }
        term.off('data');
        prepare_for_connect();
    }

}

var serviceMessageInProcess = false;
var serviceMessageResponse = "";

function sendServiceMessage(message, cb) {
    if(serviceMessageInProcess) {
        console.log("Service message already in process");
        return;
    }

    console.log("Sending service message: ", message);
    var serviceMessageSent = message + "\r\n";

    serviceMessageInProcess = true;
    serviceMessageResponse = "";

    addListener(SERVICE_MESSAGE_EVENT, serviceMessageSent, function(e) {
        console.log("Received response: ", e.detail.message);
        var serviceMessageResponse = e.detail.message.replace(serviceMessageSent,"");
        removeListener(SERVICE_MESSAGE_EVENT, serviceMessageSent);
        serviceMessageInProcess = false;
        if(cb != undefined) {
            cb(serviceMessageResponse);
        }
    });

    ws.send(serviceMessageSent);
}

var startUpReady = false;
var STARTUP_FILE = "_webrepl_utils";
function checkStartUp(cb) {
    if(startUpReady) {
        cb();
        return;
    }

    startUpReady = true;
    save_buffer(STARTUP_FILE + ".py", PYTHON_STARTUPDEFINITIONS, cb);
}

function executeFile(fileName, useTempName = false) {
    var deleteFile = useTempName ? "True" : "False"
    sendServiceMessage(`import ${STARTUP_FILE}; ${STARTUP_FILE}.execute_file('${fileName}',${deleteFile})`); 
}

function sendText(text) {
    checkStartUp(() => {
        var tmpFileName = `_tmpScratch.py`;
        // the reason we need to do it this way is that when sending text as is, the server automatically
        // adds indentation to help in interactive mode
        save_buffer(tmpFileName, text, data => { 
            executeFile(tmpFileName, true);
        });
    });
}
function send(idx) {
    var data = document.getElementById("scratchpad" + idx).value;
    sendText(data);
}

function clear(idx) {
    document.getElementById("scratchpad" + idx).value = ""
}

function scratchpadKeypress(idx,evt) {
    if(evt.code == "Enter" && evt.ctrlKey) {
        send(idx);
    }
}


function decode_resp(data) {
    if (data[0] == 'W'.charCodeAt(0) && data[1] == 'B'.charCodeAt(0)) {
        var code = data[2] | (data[3] << 8);
        return code;
    } else {
        return -1;
    }
}

function save_buffer(file_name = undefined, contents = undefined, cb = undefined) {
    if(file_name == undefined)
        put_file_name = document.getElementById('put_filename').value;
    else
        put_file_name = file_name;

    if(put_file_name == "")
        return;

    if(contents == undefined)
        contents = editor.getValue();
    put_file_data = new Uint8Array(contents.split('').map(x => x.charCodeAt(0)));
    addListener(FILE_PUT_EVENT, put_file_name, e => 
        { 
            removeListener(FILE_PUT_EVENT, put_file_name);
            if(cb != undefined) cb(e.detail);
        });
    put_file();
}
function put_file() {
    var dest_fname = put_file_name;
    var dest_fsize = put_file_data.length;

    // WEBREPL_FILE = "<2sBBQLH64s"
    var rec = new Uint8Array(2 + 1 + 1 + 8 + 4 + 2 + 64);
    rec[0] = 'W'.charCodeAt(0);
    rec[1] = 'A'.charCodeAt(0);
    rec[2] = 1; // put
    rec[3] = 0;
    rec[4] = 0; rec[5] = 0; rec[6] = 0; rec[7] = 0; rec[8] = 0; rec[9] = 0; rec[10] = 0; rec[11] = 0;
    rec[12] = dest_fsize & 0xff; rec[13] = (dest_fsize >> 8) & 0xff; rec[14] = (dest_fsize >> 16) & 0xff; rec[15] = (dest_fsize >> 24) & 0xff;
    rec[16] = dest_fname.length & 0xff; rec[17] = (dest_fname.length >> 8) & 0xff;
    for (var i = 0; i < 64; ++i) {
        if (i < dest_fname.length) {
            rec[18 + i] = dest_fname.charCodeAt(i);
        } else {
            rec[18 + i] = 0;
        }
    }

    // initiate put
    binary_state = 11;
    update_file_status('Sending ' + put_file_name + '...');
    ws.send(rec);
}

function get_file(src_fname) {
    // WEBREPL_FILE = "<2sBBQLH64s"
    var rec = new Uint8Array(2 + 1 + 1 + 8 + 4 + 2 + 64);
    rec[0] = 'W'.charCodeAt(0);
    rec[1] = 'A'.charCodeAt(0);
    rec[2] = 2; // get
    rec[3] = 0;
    rec[4] = 0; rec[5] = 0; rec[6] = 0; rec[7] = 0; rec[8] = 0; rec[9] = 0; rec[10] = 0; rec[11] = 0;
    rec[12] = 0; rec[13] = 0; rec[14] = 0; rec[15] = 0;
    rec[16] = src_fname.length & 0xff; rec[17] = (src_fname.length >> 8) & 0xff;
    for (var i = 0; i < 64; ++i) {
        if (i < src_fname.length) {
            rec[18 + i] = src_fname.charCodeAt(i);
        } else {
            rec[18 + i] = 0;
        }
    }

    // initiate get
    binary_state = 21;
    get_file_name = src_fname;
    get_file_data = new Uint8Array(0);
    update_file_status('Getting ' + get_file_name + '...');
    ws.send(rec);
}

function get_ver() {
    // WEBREPL_REQ_S = "<2sBBQLH64s"
    var rec = new Uint8Array(2 + 1 + 1 + 8 + 4 + 2 + 64);
    rec[0] = 'W'.charCodeAt(0);
    rec[1] = 'A'.charCodeAt(0);
    rec[2] = 3; // GET_VER
    // rest of "rec" is zero

    // initiate GET_VER
    binary_state = 31;
    ws.send(rec);
}

function handle_put_file_select(evt) {
    // The event holds a FileList object which is a list of File objects,
    // but we only support single file selection at the moment.
    var files = evt.target.files;

    // Get the file info and load its data.
    var f = files[0];
    put_file_name = f.name;
    var reader = new FileReader();
    reader.onload = function(e) {
        put_file_data = new Uint8Array(e.target.result);
        document.getElementById('put-file-list').innerHTML = '' + escape(put_file_name) + ' - ' + put_file_data.length + ' bytes';
        document.getElementById('put-file-button').disabled = false;
    };
    reader.readAsArrayBuffer(f);
}

// document.getElementById('put-file-select').addEventListener('click', function(){
//     this.value = null;
// }, false);

// document.getElementById('put-file-select').addEventListener('change', handle_put_file_select, false);
// document.getElementById('put-file-button').disabled = true;

var app = angular.module('webrepl',[]);
app
    .controller('main', function($scope) {
        $scope.refreshDirectories = function() {
            sendServiceMessage("[ [f,list(os.stat(f))] for f in os.listdir() ]", result => {
                var rawfiles = JSON.parse(result.replace(/'/g,'"'));
                var files = rawfiles.map(record => {
                    var folder = record[1][0] == FILETYPE_FOLDER;
                    var name = record[0];
                    return {
                        name: name,
                        size: record[1][6],
                        folder,
                    }
                });
                files = [
                    {name: "..", size: 0, folder: true }
                ].concat(files);

                $scope.files = files.map(record => {
                    record.displayName = (record.folder?"<--- " : "") + record.name
                        + (record.folder?" --->" : "")
                    return record;
                });
                
                $scope.activeFileIdx = 0;
                $scope.$apply();
            });
        }

        // QUICK HACK REALLY
        window.refreshDirectories = $scope.refreshDirectories;

        $scope.getfile = function() {
            var fileName = $scope.files[$scope.activeFileIdx].name;
            get_file(fileName);
        }

        $scope.changeFolder = function() {
            var file = $scope.files[$scope.activeFileIdx];
            if(file.folder) 
                sendServiceMessage(`os.chdir("${file.name}")`,
                () => $scope.refreshDirectories());
            else {
                $scope.fileName = file.name;
            }
        }

        $scope.runFile = function() {
            executeFile($scope.fileName, false);
        }
        $scope.importFile = function() {
            var module = $scope.fileName.replace(/.py$/,"");
            sendServiceMessage(`import ${module}`);
        }
    })

</script>

</html>
